# Creates a class to represent a permutation of 1, 2, ..., n for some n >= 0.## An object is created by passing as argument to the class name:# - either no argument, in which case the empty permutation is created, or# - "length = n" for some n >= 0, in which case the identity over 1, ..., n is# created, or# - the numbers 1, 2, ..., n for some n >= 0, in some order, possibly together# with "lengh = n".## __len__(), __repr__() and __str__() are implemented, the latter providing the# standard form# decomposition of the permutation into cycles (see wikepedia page on# permutations for details).## Objects have:# - nb_of_cycles as an attribute# - inverse() as a method## The * operator is implemented for permutation composition, for both infix and# in-place uses.## Written by *** and Eric Martin for COMP9021class PermutationError(Exception):    def __init__(self, message):        self.message = messageclass Permutation:    def __init__(self, *args, length=None):        if len(args) != 0:            for elem in args:                if not isinstance(elem, int):                    raise PermutationError("Cannot generate permutation from these arguments")            if set(args) != set(range(1, len(args) + 1)):                raise PermutationError("Cannot generate permutation from these arguments")            if length is not None and length != len(args):                raise PermutationError("Cannot generate permutation from these arguments")        if len(args) == 0 and length is not None:            if length < 0:                raise PermutationError("Cannot generate permutation from these arguments")            self.arr = []            for i in range(length):                self.arr.append(i + 1)            self.arr = tuple(self.arr)        else:            self.arr = args        self.cycles = getcycle(self.arr)        self.nb_of_cycles = len(self.cycles)    def __len__(self):        return len(self.arr)    def __repr__(self):        st = ['(']        for i in range(len(self.arr)):            if i == 0:                st.append(str(self.arr[i]))            else:                st.append(', ')                st.append(str(self.arr[i]))        st.append(')')        return "Permutation" + "".join(st)    def __str__(self):        if self.nb_of_cycles == 0:            return "()"        s = []        for tup in self.cycles:            s.append('(')            for i in range(len(tup)):                if i == 0:                    s.append(str(tup[i]))                else:                    s.append(' ' + str(tup[i]))            s.append(')')        return "".join(s)    def __mul__(self, permutation):        if len(self) != len(permutation):            raise PermutationError("Cannot compose permutations of different lengths")        sh = shift(self.arr, permutation.cycles)        return Permutation(*sh)    def __imul__(self, permutation):        return self * permutation    def inverse(self):        in_s = in_shift(self.arr, self.cycles)        return Permutation(*in_s)            # Insert your code for helper functions, if neededdef getcycle(lst):    if len(lst) == 0:        return []    if len(lst) == 1:        return [lst[0]]    else:        origin = sorted(lst)        dic_ori = dict()        for i in range(len(lst)):            dic_ori[origin[i]] = i        used = set()        cycles = list()        i = 0        while len(used) != len(lst):            cur = list()            i = 0            while i < len(lst) and i in used:                i+=1            while i < len(lst) and i not in used:                              used.add(i)                cur.append(lst[i])                  if origin[i] == lst[i]:                    break                                i = dic_ori[lst[i]]            if len(cur) != 0:                mx = 0                mi = 0                for i in range(len(cur)):                    if cur[i] > mx:                        mx = cur[i]                        mi = i                i = mi                cyc = []                while i < len(cur):                    cyc.append(cur[i])                    i+=1                i = 0                while i < mi:                    cyc.append(cur[i])                    i+=1                cycles.append(tuple(cyc))        cycles.sort()        return cyclesdef shift(lst, cycles):    rules = dict()    if len(cycles) == 0:        return lst    for comb in cycles:        for i in range(len(comb) - 1):            rules[comb[i]] = comb[i + 1]        rules[comb[-1]] = comb[0]    result = list(lst)    for i in range(len(lst)):        result[i] = rules[lst[i]]    return resultdef in_shift(lst, cycles):    in_rules = dict()    if len(cycles) == 0:        return lst    for comb in cycles:        for i in range(1,len(comb)):            in_rules[comb[i]] = comb[i - 1]        in_rules[comb[0]] = comb[-1]    result = sorted(lst)    for i in range(len(lst)):        result[i] = in_rules[result[i]]    return result                    